<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Hotel Review Sentiment Analysis ‚Äì Anna Kim</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Anna Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../leadership_volunteer.html"> 
<span class="menu-text">leadership&amp;volunteer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../experience.html"> 
<span class="menu-text">experience</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../academic.html"> 
<span class="menu-text">academic</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a>
  <ul class="collapse">
  <li><a href="#top-positive-sentiment-words" id="toc-top-positive-sentiment-words" class="nav-link" data-scroll-target="#top-positive-sentiment-words">Top Positive Sentiment Words</a></li>
  <li><a href="#top-negative-sentiment-words" id="toc-top-negative-sentiment-words" class="nav-link" data-scroll-target="#top-negative-sentiment-words">Top Negative Sentiment Words</a></li>
  </ul></li>
  <li><a href="#data-preprocessing-cleaning" id="toc-data-preprocessing-cleaning" class="nav-link" data-scroll-target="#data-preprocessing-cleaning">Data Preprocessing &amp; Cleaning</a></li>
  <li><a href="#exploratory-data-analysis" id="toc-exploratory-data-analysis" class="nav-link" data-scroll-target="#exploratory-data-analysis">Exploratory Data Analysis</a></li>
  <li><a href="#feature-engineering" id="toc-feature-engineering" class="nav-link" data-scroll-target="#feature-engineering">Feature Engineering</a></li>
  <li><a href="#sentiment-classification" id="toc-sentiment-classification" class="nav-link" data-scroll-target="#sentiment-classification">Sentiment Classification</a></li>
  <li><a href="#model-interpretability" id="toc-model-interpretability" class="nav-link" data-scroll-target="#model-interpretability">Model Interpretability</a></li>
  <li><a href="#technical-stack" id="toc-technical-stack" class="nav-link" data-scroll-target="#technical-stack">Technical Stack</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Hotel Review Sentiment Analysis</h1>
<p class="subtitle lead">Classical NLP Pipeline with Linear Model Interpretation</p>
  <div class="quarto-categories">
    <div class="quarto-category">NLP</div>
    <div class="quarto-category">Machine Learning</div>
    <div class="quarto-category">Classical NLP</div>
    <div class="quarto-category">Sentiment Analysis</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="links">
<p>üîó<a href="https://github.com/annakim9237/hotel-review-sentiment-lab"><strong>Source Code (Git)</strong></a> &nbsp;&nbsp;</p>
</div>
<section id="overview" class="level1">
<h1>Overview</h1>
<p>Understanding customer sentiment at scale is essential for hospitality management, where guest experience directly influences brand reputation, service improvements, and operational strategy. This project builds a <strong>full classical NLP workflow</strong> to analyze <strong>515,738 hotel reviews</strong> across multiple European cities, transforming unstructured text into measurable sentiment insights. Unlike deep neural models, this project emphasizes <strong>transparency and interpretability</strong>, demonstrating how linear models and careful preprocessing can extract actionable findings from large corpora.</p>
<p>The workflow begins by developing a robust text cleaning pipeline capable of handling a large multilingual review dataset. After data quality checks‚Äîincluding removal of 539 duplicate records‚Äîthe text undergoes normalization (lowercasing, punctuation stripping, numeric filtering, stopword removal) followed by tokenization and lemmatization to unify morphological variations. These steps create a consistent corpus suitable for downstream modeling.</p>
<p>Exploratory analysis uncovers foundational linguistic structures in the data: review length patterns, frequent tokens and n-grams, lexical diversity, and metadata distributions across six hotel cities (Amsterdam, Barcelona, London, Milan, Paris, Vienna). Temporal patterns highlight how feedback varies across seasons and trip types, revealing behavioral insights about guests.</p>
<p>Classical vectorization techniques‚ÄîBag-of-Words and TF-IDF‚Äîconvert text into numerical representations capturing both raw token frequency and discriminative significance. These transformed features feed into sentiment classification models including Logistic Regression, Naive Bayes, and Linear SVM, evaluated via accuracy, precision, recall, and F1 score using stratified splits.</p>
<p>A key contribution of this project is interpretability: by extracting and ranking coefficient weights from linear models, the system identifies linguistic drivers of sentiment. High-positive terms such as <em>perfect</em>, <em>excellent</em>, <em>lovely</em>, <em>fine</em>, and <em>easy</em> contrast sharply with negative markers like <em>dirty</em>, <em>worst</em>, <em>broken</em>, <em>dated</em>, <em>noisy</em>, and <em>overpriced</em>. These indicators reflect concrete service dimensions‚Äîcleanliness, staff behavior, comfort, and value‚Äîdirectly informing business action.</p>
<p>This project demonstrates how classical NLP paired with interpretable machine learning provides a powerful, transparent, and operationally useful framework for evaluating customer experience at scale. The methodology is fully reproducible and modular, enabling extension to other industries or multilingual settings.</p>
<hr>
<section id="top-positive-sentiment-words" class="level2">
<h2 class="anchored" data-anchor-id="top-positive-sentiment-words">Top Positive Sentiment Words</h2>
<p><img src="Positive.png" class="img-fluid" style="width:85.0%"></p>
</section>
<section id="top-negative-sentiment-words" class="level2">
<h2 class="anchored" data-anchor-id="top-negative-sentiment-words">Top Negative Sentiment Words</h2>
<p><img src="Negative.png" class="img-fluid" style="width:85.0%"></p>
<hr>
</section>
</section>
<section id="data-preprocessing-cleaning" class="level1">
<h1>Data Preprocessing &amp; Cleaning</h1>
<ul>
<li>Processed <strong>515,738 hotel reviews</strong></li>
<li>Removed <strong>539 duplicates</strong></li>
<li>Normalization:
<ul>
<li>lowercasing<br>
</li>
<li>punctuation &amp; numeric filtering<br>
</li>
<li>whitespace cleanup<br>
</li>
</ul></li>
<li>NLP steps:
<ul>
<li>tokenization<br>
</li>
<li>NLTK stopword removal<br>
</li>
<li>lemmatization for morphological consistency<br>
</li>
</ul></li>
<li>Developed reusable preprocessing functions for consistent transformation</li>
</ul>
<hr>
</section>
<section id="exploratory-data-analysis" class="level1">
<h1>Exploratory Data Analysis</h1>
<ul>
<li>Review length distributions, lexical diversity measures<br>
</li>
<li>Unigram &amp; bigram frequency analysis<br>
</li>
<li>Positive vs.&nbsp;negative sentiment token patterns<br>
</li>
<li>Reviewer nationality distribution across six hotel cities<br>
</li>
<li>Temporal analysis (day, month, year)<br>
</li>
<li>Stay duration &amp; trip type segmentation (leisure vs business)</li>
</ul>
<hr>
</section>
<section id="feature-engineering" class="level1">
<h1>Feature Engineering</h1>
<ul>
<li>Bag-of-Words (BoW) document-term matrix<br>
</li>
<li>TF-IDF vectorization capturing discriminative term weights<br>
</li>
<li>N-gram (unigram/bigram) feature extraction<br>
</li>
<li>Contextual multi-word expression modeling</li>
</ul>
<hr>
</section>
<section id="sentiment-classification" class="level1">
<h1>Sentiment Classification</h1>
<p>Models trained: - Logistic Regression (L1 &amp; L2 regularization)<br>
- Multinomial Naive Bayes<br>
- Linear SVM (maximum-margin classifier)</p>
<p>Evaluation: - Stratified train‚Äìtest split<br>
- Accuracy, precision, recall, F1-score<br>
- Confusion matrix analysis</p>
<hr>
</section>
<section id="model-interpretability" class="level1">
<h1>Model Interpretability</h1>
<p>Extracted linear model coefficients to identify sentiment-driving terms.</p>
<p><strong>Positive sentiment indicators:</strong> - <em>perfect</em>, <em>excellent</em>, <em>great</em>, <em>lovely</em>, <em>fine</em>, <em>easy</em></p>
<p><strong>Negative indicators:</strong> - <em>dirty</em>, <em>worst</em>, <em>terrible</em>, <em>horrible</em>, <em>dated</em>, <em>broken</em>, <em>worn</em>, <em>noisy</em>, <em>uncomfortable</em>, <em>overpriced</em></p>
<p>Contextual findings: - Some negative words appear in positive reviews due to <strong>negation patterns</strong><br>
(‚Äúnot terrible‚Äù, ‚Äúno issues, nothing horrible‚Äù)</p>
<p>Business insights extracted: - Cleanliness issues<br>
- Staff interaction quality<br>
- Facility age/maintenance<br>
- Room comfort<br>
- Value-for-money perception</p>
<hr>
</section>
<section id="technical-stack" class="level1">
<h1>Technical Stack</h1>
<ul>
<li>Python, Pandas, NumPy<br>
</li>
<li>NLTK (preprocessing)<br>
</li>
<li>scikit-learn (vectorization + modeling)<br>
</li>
<li>Matplotlib, Seaborn (EDA visualizations)</li>
</ul>
<hr>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>This project provides a fully interpretable, end-to-end NLP pipeline that demonstrates how large-scale customer reviews can be systemically transformed into actionable insights for hospitality management. The use of classical vectorization and linear modeling‚Äîrather than opaque deep learning‚Äîallows stakeholders to understand <em>why</em> specific reviews are classified as positive or negative, aligning the output with operational decision-making.</p>
<p>The interpretability of coefficient weights highlights recurring service strengths and pain points, enabling managers to prioritize resource allocation. Cleanliness-related complaints consistently emerge as the strongest negative drivers, while words denoting ease, comfort, and staff quality dominate positive sentiment.</p>
<p>Beyond hospitality, this pipeline serves as a blueprint for scalable sentiment analysis in any domain where textual customer feedback is abundant. Its modular and transparent design makes it well-suited for enterprise analytics workflows, quality monitoring systems, and multilingual expansion. The results underscore how classical NLP continues to provide value through clarity, stability, and explainability‚Äîqualities essential for business strategy and consumer experience optimization.</p>
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/kim-anna\.quarto\.pub\/anna-kim");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>